version: 0.2

env:
  variables:
    AWS_ACCOUNT_ID: "586359898361"
    IMAGE_REPO_NAME: "nartex-next"
    NEXTAUTH_URL: "https://app.nartex.ca"
    EMAIL_SERVER_HOST: "smtp.gmail.com"
    EMAIL_SERVER_PORT: "587"
    EMAIL_SERVER_USER: "n.labranche@nartex.ca"
    EMAIL_FROM: "Nartex <noreply@nartex.ca>"
    AZURE_AD_TENANT_ID: "organizations"

  secrets-manager:
    EMAIL_SERVER_PASSWORD:  nartex/prod/env:EMAIL_SERVER_PASSWORD
    NEXTAUTH_SECRET:        nartex/prod/env:NEXTAUTH_SECRET
    GOOGLE_CLIENT_ID:       nartex/prod/env:GOOGLE_CLIENT_ID
    GOOGLE_CLIENT_SECRET:   nartex/prod/env:GOOGLE_CLIENT_SECRET
    AZURE_AD_CLIENT_ID:     nartex/prod/env:AZURE_AD_CLIENT_ID
    AZURE_AD_CLIENT_SECRET: nartex/prod/env:AZURE_AD_CLIENT_SECRET
    RDS_CREDENTIALS:        nartex/prod/rds-credentials
    # If you still want to pass a direct connection string during build, uncomment:
    # DATABASE_URL:           nartex/prod/env:DATABASE_URL

phases:
  install:
    runtime-versions:
      nodejs: 18
    commands:
      - echo "ðŸ“¦ INSTALL â€“ npm ci for workspace tooling"
      - npm ci
      
  pre_build:
    commands:
      - echo "ðŸ“œ PRE_BUILD â€“ write script to disk and run it"
      - |
        cat > ci-prebuild.sh << 'SH'
        #!/usr/bin/env bash
        set -euo pipefail
        set -x
  
        # 1) Ensure runtime deps used by dashboard
        npm pkg set dependencies.recharts="^2.12.7"
        npm pkg set dependencies.lucide-react="^0.452.0"
        npm pkg set dependencies.class-variance-authority="^0.7.0"
        npm pkg set dependencies.clsx="^2.1.1"
        npm pkg set dependencies.tailwind-merge="^2.5.2"
        npm pkg set dependencies.tailwindcss-animate="^1.0.7"
        npm pkg set dependencies.pg="^8.11.3"
        npm pkg set dependencies.swr="^2.3.0"
  
        # 1b) **ADDED** â€“ typings for server libs
        npm pkg set devDependencies.@types/node="^18.19.0"
        npm pkg set devDependencies.@types/pg="^8.11.7"
  
        # 2) Ensure shadcn config exists (donâ€™t error if already present)
        node <<'NODE'
        const fs = require('fs');
        const p = 'components.json';
        const j = fs.existsSync(p) ? JSON.parse(fs.readFileSync(p,'utf8')) : {};
        j.$schema = 'https://ui.shadcn.com/schema.json';
        j.style = 'default';
        j.rsc = true;
        j.tsx = true;
        j.tailwind = { config: 'tailwind.config.ts', css: 'src/app/globals.css', baseColor: 'gray', cssVariables: true };
        j.aliases = { components: '@/components', utils: '@/lib/utils' };
        j.iconLibrary = 'lucide';
        j.components = j.components || [];
        j.path = 'src/components';
        fs.writeFileSync(p, JSON.stringify(j, null, 2));
        NODE
  
        mkdir -p src/lib src/components/ui
  
        # minimal cn() helper if missing (unchanged) ...
        # shadcn init + components (unchanged) ...
  
        echo "ðŸ“‚ Components present:"; ls -la src/components/ui || true
  
        # 3) **ADDED** â€“ relax TS lib checking so pg/node types donâ€™t choke the build
        node <<'NODE'
        const fs = require('fs');
        const p = 'tsconfig.json';
        const j = fs.existsSync(p) ? JSON.parse(fs.readFileSync(p,'utf8')) : { compilerOptions:{} };
        j.compilerOptions = j.compilerOptions || {};
        j.compilerOptions.skipLibCheck = true;
        j.compilerOptions.types = Array.from(new Set([...(j.compilerOptions.types||[]), 'node']));
        fs.writeFileSync(p, JSON.stringify(j, null, 2));
        NODE
  
        # 4) Refresh lockfile so Docker's npm ci installs exactly these deps
        npm install --package-lock-only --ignore-scripts --no-audit --no-fund
        SH
      - chmod +x ci-prebuild.sh
      - bash ci-prebuild.sh

  build:
    commands:
      - echo "ðŸ— BUILD â€“ resolve commit hash"
      - COMMIT_HASH=$(git rev-parse --short HEAD)
      - echo "ðŸ— BUILD â€“ docker image (no cache)"
      - ECR_IMAGE_URI="$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME"
      - |
        docker build \
          --no-cache \
          --build-arg GIT_COMMIT_HASH=$COMMIT_HASH \
          --build-arg DATABASE_URL="$DATABASE_URL" \
          --build-arg EMAIL_SERVER_HOST="$EMAIL_SERVER_HOST" \
          --build-arg EMAIL_SERVER_PORT="$EMAIL_SERVER_PORT" \
          --build-arg EMAIL_SERVER_USER="$EMAIL_SERVER_USER" \
          --build-arg EMAIL_SERVER_PASSWORD="$EMAIL_SERVER_PASSWORD" \
          --build-arg EMAIL_FROM="$EMAIL_FROM" \
          --build-arg NEXTAUTH_URL="$NEXTAUTH_URL" \
          --build-arg NEXTAUTH_SECRET="$NEXTAUTH_SECRET" \
          --build-arg GOOGLE_CLIENT_ID="$GOOGLE_CLIENT_ID" \
          --build-arg GOOGLE_CLIENT_SECRET="$GOOGLE_CLIENT_SECRET" \
          --build-arg AZURE_AD_CLIENT_ID="$AZURE_AD_CLIENT_ID" \
          --build-arg AZURE_AD_CLIENT_SECRET="$AZURE_AD_CLIENT_SECRET" \
          --build-arg AZURE_AD_TENANT_ID="$AZURE_AD_TENANT_ID" \
          -t "$ECR_IMAGE_URI:$COMMIT_HASH" \
          -t "$ECR_IMAGE_URI:latest" .

      - echo "ðŸ”‘ Login to ECR"
      - |
        PASS="$(aws ecr get-login-password --region "$AWS_DEFAULT_REGION")"
        echo "$PASS" | docker login --username AWS --password-stdin "$ECR_IMAGE_URI"

      - echo "ðŸ“¤ Push images"
      - docker push "$ECR_IMAGE_URI:$COMMIT_HASH"
      - docker push "$ECR_IMAGE_URI:latest"

  post_build:
    commands:
      - echo "ðŸ”„ Force new ECS deployment"
      - |
        aws ecs update-service \
          --cluster nartex-cluster \
          --service nartex-next-service \
          --force-new-deployment \
          --region $AWS_DEFAULT_REGION
        # Tip: for bullet-proof rollouts, update task def to the exact $COMMIT_HASH tag.

artifacts:
  files:
    - imagedefinitions.json
