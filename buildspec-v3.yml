version: 0.2

env:
  variables:
    AWS_DEFAULT_REGION: "ca-central-1"
    AWS_ACCOUNT_ID: "586359898361"
    IMAGE_REPO_NAME: "nartex-next"
    CONTAINER_NAME: "nextjs"
    NEXTAUTH_URL: "https://app.nartex.ca"
    EMAIL_SERVER_HOST: "smtp.gmail.com"
    EMAIL_SERVER_PORT: "587"
    EMAIL_SERVER_USER: "n.labranche@nartex.ca"
    EMAIL_FROM: "Nartex <noreply@nartex.ca>"
    AZURE_AD_TENANT_ID: "organizations"
  secrets-manager:
    DATABASE_URL:           nartex/prod/env:DATABASE_URL
    EMAIL_SERVER_PASSWORD:  nartex/prod/env:EMAIL_SERVER_PASSWORD
    NEXTAUTH_SECRET:        nartex/prod/env:NEXTAUTH_SECRET
    GOOGLE_CLIENT_ID:       nartex/prod/env:GOOGLE_CLIENT_ID
    GOOGLE_CLIENT_SECRET:   nartex/prod/env:GOOGLE_CLIENT_SECRET
    AZURE_AD_CLIENT_ID:     nartex/prod/env:AZURE_AD_CLIENT_ID
    AZURE_AD_CLIENT_SECRET: nartex/prod/env:AZURE_AD_CLIENT_SECRET
    RDS_CREDENTIALS:        nartex/prod/rds-credentials

phases:
  install:
    runtime-versions:
      nodejs: 22   # keep host up to date; weâ€™re not installing modules here
    commands:
      - echo "ðŸ“¦ INSTALL â€“ no host npm install; Docker handles dependencies."
      # Patch the bad ESLint package name if present (both deps & devDeps)
      - |
        node -e "const fs=require('fs');const p='package.json';
        if(fs.existsSync(p)){
          const j=JSON.parse(fs.readFileSync(p,'utf8'));
          for(const k of ['dependencies','devDependencies']){
            if(j[k] && j[k]['@eslint/eslinrc']){
              delete j[k]['@eslint/eslinrc'];
              console.log('Removed @eslint/eslinrc from', k);
            }
          }
          fs.writeFileSync(p, JSON.stringify(j,null,2));
        } else { console.log('package.json not found; skipping patch'); }"
  pre_build:
    commands:
      - echo "ðŸ“œ PRE_BUILD â€“ write helper script and refresh lockfile only"
      - |
        cat > ci-prebuild.sh << 'SH'
        #!/usr/bin/env bash
        set -euo pipefail
        set -x

        # Ensure we don't have the legacy auth file that collides with NextAuth
        rm -f src/lib/auth.ts || true

        # Ensure basic UI/runtime deps (idempotent)
        npm pkg set dependencies.recharts="^2.12.7"
        npm pkg set dependencies.lucide-react="^0.452.0"
        npm pkg set dependencies.class-variance-authority="^0.7.0"
        npm pkg set dependencies.clsx="^2.1.1"
        npm pkg set dependencies.tailwind-merge="^2.5.2"
        npm pkg set dependencies.tailwindcss-animate="^1.0.7"
        npm pkg set dependencies.pg="^8.11.3"
        npm pkg set dependencies.swr="^2.3.0"
        npm pkg set dependencies.@next-auth/prisma-adapter="^1.0.7"

        # Types for CI tooling if needed
        npm pkg set devDependencies.@types/node="^18.19.0"
        npm pkg set devDependencies.@types/pg="^8.11.7"

        # Guarantee lucide ChevronDown import is available (weâ€™ll fix source below)
        # and ensure a minimal prisma helper exists if missing.
        mkdir -p src/lib
        if [ ! -f src/lib/prisma.ts ]; then
          cat > src/lib/prisma.ts <<'TS'
        import { PrismaClient } from "@prisma/client";
        const globalForPrisma = global as unknown as { prisma?: PrismaClient };
        export const prisma = globalForPrisma.prisma ?? new PrismaClient();
        if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;
        export default prisma;
        TS
        fi

        # Refresh lockfile only, so Docker uses a clean, corrected lock
        npm install --package-lock-only --ignore-scripts --no-audit --no-fund
        SH
      - chmod +x ci-prebuild.sh
      - bash ci-prebuild.sh

      # Resolve a short commit hash for tagging
      - COMMIT_HASH=$(git rev-parse --short HEAD)
      - echo "Commit hash: $COMMIT_HASH"

  build:
    commands:
      - echo "ðŸ— BUILD â€“ docker image (dependencies installed inside Docker build)"
      - ECR_IMAGE_URI="$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME"
      - |
        docker build \
          --build-arg GIT_COMMIT_HASH="$COMMIT_HASH" \
          --build-arg DATABASE_URL="$DATABASE_URL" \
          --build-arg EMAIL_SERVER_HOST="$EMAIL_SERVER_HOST" \
          --build-arg EMAIL_SERVER_PORT="$EMAIL_SERVER_PORT" \
          --build-arg EMAIL_SERVER_USER="$EMAIL_SERVER_USER" \
          --build-arg EMAIL_SERVER_PASSWORD="$EMAIL_SERVER_PASSWORD" \
          --build-arg EMAIL_FROM="$EMAIL_FROM" \
          --build-arg NEXTAUTH_URL="$NEXTAUTH_URL" \
          --build-arg NEXTAUTH_SECRET="$NEXTAUTH_SECRET" \
          --build-arg GOOGLE_CLIENT_ID="$GOOGLE_CLIENT_ID" \
          --build-arg GOOGLE_CLIENT_SECRET="$GOOGLE_CLIENT_SECRET" \
          --build-arg AZURE_AD_CLIENT_ID="$AZURE_AD_CLIENT_ID" \
          --build-arg AZURE_AD_CLIENT_SECRET="$AZURE_AD_CLIENT_SECRET" \
          --build-arg AZURE_AD_TENANT_ID="$AZURE_AD_TENANT_ID" \
          -t "$ECR_IMAGE_URI:$COMMIT_HASH" \
          -t "$ECR_IMAGE_URI:latest" .

      - echo "ðŸ”‘ Login to ECR"
      - |
        PASS="$(aws ecr get-login-password --region "$AWS_DEFAULT_REGION")"
        echo "$PASS" | docker login --username AWS --password-stdin "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com"

      - echo "ðŸ“¤ Push images"
      - docker push "$ECR_IMAGE_URI:$COMMIT_HASH"
      - docker push "$ECR_IMAGE_URI:latest"

  post_build:
    commands:
      - echo "âœ… BUILD â€“ Creating imagedefinitions.json for ECS deployment"
      - COMMIT_HASH=$(git rev-parse --short HEAD)
      - ECR_IMAGE_URI="$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME"
      - |
        cat > imagedefinitions.json << EOF
        [
          { "name": "$CONTAINER_NAME", "imageUri": "$ECR_IMAGE_URI:$COMMIT_HASH" }
        ]
        EOF
      - echo "ðŸ“‹ Contents of imagedefinitions.json:"
      - cat imagedefinitions.json

artifacts:
  files:
    - imagedefinitions.json
