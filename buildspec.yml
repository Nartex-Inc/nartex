version: 0.2

env:
  variables:
    AWS_DEFAULT_REGION: "ca-central-1"
    AWS_ACCOUNT_ID: "586359898361"
    IMAGE_REPO_NAME: "nartex-next"
    CONTAINER_NAME: "nextjs"

  secrets-manager:
    # Used by prisma migrate deploy / db seed (runs on CodeBuild host)
    DATABASE_URL:           nartex/prod/env:DATABASE_URL
    RDS_CREDENTIALS:        nartex/prod/rds-credentials
    # Inlined into client JS bundles at docker build time (NEXT_PUBLIC_*)
    NEXT_PUBLIC_GOOGLE_MAPS_API_KEY: nartex/prod/env:GOOGLE_MAPS_API_KEY

phases:
  install:
    runtime-versions:
      nodejs: 20
    commands:
      # Fix memory on the Host (CodeBuild itself)
      - export NODE_OPTIONS="--max-old-space-size=4096"
      - export NEXT_TELEMETRY_DISABLED=1

      - echo "ðŸ“¦ INSTALL â€“ clean cache and prep lockfile"
      - npm cache clean --force
      - npm ci --legacy-peer-deps

      # Install dependencies (Auth, PDF, Email, Google, Maps)
      - npm install --legacy-peer-deps @simplewebauthn/browser @simplewebauthn/server jspdf jspdf-autotable googleapis @react-google-maps/api
      - npm install --legacy-peer-deps --save-dev @types/nodemailer

      - node -e "console.log('prisma:',require('./node_modules/prisma/package.json').version,'| @prisma/client:',require('./node_modules/@prisma/client/package.json').version)"

  pre_build:
    commands:
      - echo "ðŸ”Ž PRE_BUILD â€“ detecting changes"

      - |
        /usr/bin/env bash -c '
        set -e
        # Unshallow the clone so parent commits are available for diff
        git fetch --unshallow 2>/dev/null || git fetch --depth=2 2>/dev/null || true
        BASE_COMMIT=$(git rev-parse HEAD^ 2>/dev/null || true)
        if [ -z "${BASE_COMMIT:-}" ]; then
          BASE_COMMIT=$(git rev-list --max-parents=0 HEAD)
        fi
        CHANGED_FILES=$(git diff --name-only "$BASE_COMMIT"...HEAD 2>/dev/null || git show --pretty="" --name-only HEAD)
        
        BUILD_TYPE=full
        NON_FRONTEND_CHANGES=$(echo "$CHANGED_FILES" | grep -vE "\.(tsx|ts|css|json|md)$|/app/|/components/|/lib/|/public/|tailwind\.config\.ts|next\.config\.ts|package-lock\.json" || true)
        if [ -z "$NON_FRONTEND_CHANGES" ] && [ -n "$CHANGED_FILES" ]; then
          echo "âœ… Frontend-only changes detected. Fast build."
          BUILD_TYPE=frontend
        else
          echo "âš ï¸ Backend/infrastructure changes detected or no diff; full build."
        fi

        PRISMA_CHANGES=$(echo "$CHANGED_FILES" | grep -E "^prisma/schema\.prisma|^prisma/migrations/" || true)
        if [ -n "$PRISMA_CHANGES" ] || [ "$BUILD_TYPE" = "full" ]; then
          NEEDS_MIGRATE=true
        else
          NEEDS_MIGRATE=false
        fi

        echo BUILD_TYPE=$BUILD_TYPE        >  /tmp/cb_env
        echo NEEDS_MIGRATE=$NEEDS_MIGRATE >> /tmp/cb_env
        '

      # --- ðŸ”§ DOCKERFILE HOT-PATCHING (Fixes OOM & Prisma Error) ---
      - echo "ðŸ”§ PRE_BUILD â€“ patching Dockerfile for memory limits and prisma generation"
      - |
        # 1. Inject NODE_OPTIONS right after FROM to fix OOM inside Docker
        sed -i '/^FROM /a ENV NODE_OPTIONS="--max-old-space-size=4096"' Dockerfile
        
        # 2. Force prisma generate to run before npm run build inside Docker
        #    This fixes "Attempted import error: 'prisma' is not exported"
        sed -i '/npm run build/i RUN npx prisma generate' Dockerfile
        
        # 3. Print the patched Dockerfile (first 20 lines and build section) for verification
        echo "â¬‡ï¸ Patched Dockerfile Preview:"
        head -n 20 Dockerfile
        grep -C 2 "npm run build" Dockerfile || true

      - echo "ðŸ“œ PRE_BUILD â€“ preparing workspace (UI stubs)"
      - |
        cat > ci-prebuild.sh << 'SH'
        set -e
        # shadcn config
        node <<'NODE'
        const fs = require('fs');
        const p = 'components.json';
        const j = fs.existsSync(p) ? JSON.parse(fs.readFileSync(p,'utf8')) : {};
        j.$schema = 'https://ui.shadcn.com/schema.json';
        j.style = 'default'; j.rsc = true; j.tsx = true;
        j.tailwind = { config: 'tailwind.config.ts', css: 'src/app/globals.css', baseColor: 'gray', cssVariables: true };
        j.aliases = { components: '@/components', utils: '@/lib/utils' };
        j.iconLibrary = 'lucide'; j.components = j.components || []; j.path = 'src/components';
        fs.writeFileSync(p, JSON.stringify(j, null, 2));
        NODE

        mkdir -p src/lib src/components/ui src/components/dashboard

        if [ ! -f src/lib/utils.ts ]; then
          cat > src/lib/utils.ts << 'TS'
        import type { ClassValue } from "clsx";
        import clsx from "clsx";
        import { twMerge } from "tailwind-merge";
        export function cn(...inputs: ClassValue[]) { return twMerge(clsx(inputs)); }
        TS
        fi

        # ---- UI stubs ----
        cat > src/components/ui/card.tsx << 'TSX'
        import * as React from "react";
        import { cn } from "@/lib/utils";
        export function Card({ className = "", children }: React.PropsWithChildren<{ className?: string }>) {
          return <div className={cn("rounded-xl border border-white/10 bg-white/[0.02] p-4", className)}>{children}</div>;
        }
        export function CardTitle({ className = "", icon, children }: React.PropsWithChildren<{ className?: string; icon?: React.ReactNode }>) {
          return <div className={cn("mb-2 flex items-center gap-2 text-sm font-semibold text-gray-200", className)}>{icon}{children}</div>;
        }
        export default Card;
        TSX

        [ -f src/components/nartex-logo.tsx ] || cat > src/components/nartex-logo.tsx << 'TSX'
        export default function NartexLogo({ className="" }: { className?: string }) {
          return <span className={className} style={{ fontWeight: 600, letterSpacing: ".05em" }}>nartex</span>;
        }
        TSX

        [ -f src/components/dashboard/header.tsx ] || cat > src/components/dashboard/header.tsx << 'TSX'
        export default function DashboardHeader(){ return <div className="px-4 py-3 text-sm text-muted-foreground">Dashboard Header</div>; }
        TSX

        [ -f src/components/dashboard/Sidebar.tsx ] || cat > src/components/dashboard/Sidebar.tsx << 'TSX'
        export default function DashboardSidebar(){ return <aside className="p-4 text-sm text-muted-foreground">Sidebar</aside>; }
        TSX

        [ -f src/components/dashboard/new-product-requests-table.tsx ] || cat > src/components/dashboard/new-product-requests-table.tsx << 'TSX'
        export default function NewProductRequestsTable(){ return <div className="p-4 text-sm text-muted-foreground">New product requests (stub)</div>; }
        TSX

        [ -f src/components/product-requests-table.tsx ] || cat > src/components/product-requests-table.tsx << 'TSX'
        export default function ProductRequestsTable(){ return <div className="p-4 text sm text-muted-foreground">Product requests (stub)</div>; }
        TSX
        SH
      - chmod +x ci-prebuild.sh
      - bash ci-prebuild.sh

  build:
    commands:
      - |
        set -e
        [ -f /tmp/cb_env ] && . /tmp/cb_env || true
        echo "BUILD_TYPE=${BUILD_TYPE:-full}"
        echo "NEEDS_MIGRATE=${NEEDS_MIGRATE:-true}"

      - npx prisma -v
      - |
        if [ "${NEEDS_MIGRATE:-true}" = "true" ]; then
          echo "ðŸš€ BUILD â€“ applying prisma migrations"
          npx prisma migrate deploy --schema=prisma/schema.prisma
          /usr/bin/env bash -c 'set -euo pipefail; echo "SELECT 1;" | npx prisma db execute --schema=prisma/schema.prisma --stdin'
          echo "ðŸŒ± BUILD â€“ seeding database"
          npx prisma db seed
        else
          echo "â© BUILD â€“ skipping migrate deploy"
        fi
      - echo "âš™ï¸ BUILD â€“ generate prisma client (Host)"
      - npx prisma generate --schema=prisma/schema.prisma

      - echo "ðŸ— BUILD â€“ resolve commit hash"
      - COMMIT_HASH=$(git rev-parse --short HEAD)
      - echo "COMMIT_HASH=$COMMIT_HASH"

      - ECR_IMAGE_URI="$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME"

      - echo "ðŸ³ BUILD â€“ docker image (build & tag)"
      # Note: We added memory limits via Dockerfile patching in pre_build
      # Only pass build-time args (NEXT_PUBLIC_* for webpack inlining).
      # All secrets are injected at runtime via ECS Task Definition + Secrets Manager.
      - |
        docker build --pull --progress=plain \
          --build-arg GIT_COMMIT_HASH="$COMMIT_HASH" \
          --build-arg NEXT_PUBLIC_GOOGLE_MAPS_API_KEY="$NEXT_PUBLIC_GOOGLE_MAPS_API_KEY" \
          -t "$ECR_IMAGE_URI:$COMMIT_HASH" \
          -t "$ECR_IMAGE_URI:latest" .

      - echo "ðŸ§¾ BUILD â€“ write imagedefinitions.json artifact"
      - |
        printf '[{"name":"%s","imageUri":"%s"}]\n' \
          "$CONTAINER_NAME" "$ECR_IMAGE_URI:$COMMIT_HASH" > imagedefinitions.json
        cat imagedefinitions.json

      - echo "ðŸ”‘ Login to ECR"
      - aws ecr get-login-password --region "$AWS_DEFAULT_REGION" | docker login --username AWS --password-stdin "$ECR_IMAGE_URI"

      - echo "ðŸ“¤ Push images"
      - docker push "$ECR_IMAGE_URI:$COMMIT_HASH"
      - docker push "$ECR_IMAGE_URI:latest"

  post_build:
    commands:
      - echo "ðŸ”„ Force new ECS deployment"
      - |
        aws ecs update-service \
          --cluster nartex-cluster \
          --service nartex-next-service \
          --force-new-deployment \
          --region "$AWS_DEFAULT_REGION"

artifacts:
  files:
    - imagedefinitions.json
