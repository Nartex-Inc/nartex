// prisma/schema.prisma

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-1.0.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

////////////////////////////////////////////////////////////////////////////////
// 0) ENUMS
////////////////////////////////////////////////////////////////////////////////

enum ProductLifecycleStage {
  DEMANDE_IDEATION
  EVALUATION_COUT_POTENTIEL
  PROTOTYPAGE
  MISE_EN_FONCTION_DEVELOPPEMENT
  PLANIFICATION_PRODUIT_FINI
  MISE_EN_MARCHE
  VIE_DU_PRODUIT
}

// Mapped from user.role
enum UserRole {
  Gestionnaire
  Analyste
  Verificateur @map("VÃ©rificateur")
  Facturation
  Expert
  user // Kept for backward compatibility with existing default
}

// Mapped from retour_ini.signale_par
enum Reporter {
  expert
  transporteur
  client
  prise_commande
  autre
}

// Mapped from retour_ini.cause_retour
enum Cause {
  production
  pompe
  autre_cause
  exposition_sinto
  transporteur
  client
  expert
  expedition
  analyse
  defect
  surplus_inventaire
  prise_commande
  rappel
  redirection
  fournisseur
  autre
}

////////////////////////////////////////////////////////////////////////////////
// 1) AUTH / USERS  (schema: public)
////////////////////////////////////////////////////////////////////////////////

model User {
  id            String    @id @default(cuid())
  name          String?
  firstName     String?   @map("first_name")
  lastName      String?   @map("last_name")
  email         String?   @unique
  emailVerified DateTime? @map("email_verified")
  image         String?

  // Mapped to `password_hash` concept, though NextAuth usually uses `password`
  password String? @map("password_hash")

  // Updated to use the specific Enum from your SQL
  role UserRole @default(user)

  canManageTickets Boolean @default(false) @map("can_manage_tickets")

  verificationToken    String?   @unique @map("verification_token")
  passwordResetToken   String?   @unique @map("password_reset_token")
  passwordResetExpires DateTime? @map("password_reset_expires")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  accounts            Account[]
  sessions            Session[]
  tenants             UserTenant[]
  supportTickets      SupportTicket[]
  notifications       Notification[]
  webauthnCredentials WebAuthnCredential[]
  sentInvitations     Invitation[]

  @@index([role])
  @@index([email])
  @@map("users")
}

model WebAuthnCredential {
  id           String   @id @default(cuid())
  userId       String   @map("user_id")
  credentialId String   @unique @map("credential_id")
  publicKey    Bytes    @map("public_key")
  counter      BigInt   @default(0)
  transports   String[] @default([])
  createdAt    DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("webauthn_credentials")
}

model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  ext_expires_in    Int?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

////////////////////////////////////////////////////////////////////////////////
// 2) MULTI-TENANCY  (schema: public)
////////////////////////////////////////////////////////////////////////////////

model Tenant {
  id            String   @id @default(uuid())
  name          String
  slug          String   @unique
  plan          String?
  logo          String?
  address       String?
  city          String?
  province      String?
  postalCode    String?  @map("postal_code")
  phone         String?
  prextraSchema String?  @map("prextra_schema")
  isActive      Boolean  @default(true) @map("is_active")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  users           UserTenant[]
  projects        Project[]
  sharePointNodes SharePointNode[]
  returns         Return[]
  supportTickets  SupportTicket[]
  invitations     Invitation[]

  @@map("tenants")
}

model UserTenant {
  userId    String
  tenantId  String
  role      String?
  createdAt DateTime @default(now()) @map("created_at")

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@id([userId, tenantId])
  @@map("user_tenants")
}

model Invitation {
  id        String   @id @default(uuid())
  email     String
  role      UserRole @default(user)
  tenantId  String   @map("tenant_id")
  invitedBy String   @map("invited_by")
  token     String   @unique @default(uuid())
  status    String   @default("pending") // pending, accepted, expired
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  tenant  Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  inviter User   @relation(fields: [invitedBy], references: [id], onDelete: Cascade)

  @@index([email])
  @@index([token])
  @@index([tenantId])
  @@index([status])
  @@map("invitations")
}

model Project {
  id        String                @id @default(uuid())
  name      String
  stage     ProductLifecycleStage
  tenantId  String
  createdAt DateTime              @default(now()) @map("created_at")
  updatedAt DateTime              @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("projects")
}

model SharePointNode {
  id           String   @id @default(cuid())
  tenantId     String
  parentId     String?
  name         String
  type         String   @default("folder")
  icon         String?
  restricted   Boolean  @default(false)
  highSecurity Boolean  @default(false)
  editGroups   String[] @default([])
  readGroups   String[] @default([])
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tenant   Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  parent   SharePointNode?  @relation("SPChildren", fields: [parentId], references: [id], onDelete: Cascade)
  children SharePointNode[] @relation("SPChildren")

  @@index([tenantId])
  @@index([tenantId, parentId])
  @@map("sharepoint_nodes")
}

////////////////////////////////////////////////////////////////////////////////
// 3) RETURNS DOMAIN - MATCHING SQL TABLES
////////////////////////////////////////////////////////////////////////////////

model Return {
  id       Int    @id @default(autoincrement())
  tenantId String @map("tenant_id")

  // Basic info
  reportedAt DateTime
  reporter   Reporter @default(expert)
  cause      Cause    @default(production)
  expert     String?

  // Financials
  amount           Decimal? @db.Decimal(10, 2)
  transportAmount  Decimal? @db.Decimal(10, 2)
  restockingAmount Decimal? @db.Decimal(10, 2)

  // Client & Order Info
  client       String?
  noClient     String? @db.VarChar(50)
  noCommande   String? @db.VarChar(50)
  noTracking   String? @db.VarChar(100)
  dateCommande String? @db.VarChar(100)
  description  String? @db.Text
  transporteur String?

  // Flags
  returnPhysical     Boolean  @default(false)
  isDraft            Boolean  @default(false)
  isFinal            Boolean  @default(false)
  isVerified         Boolean  @default(false)
  isStandby          Boolean  @default(false)
  isPickup           Boolean  @default(false)
  isCommande         Boolean  @default(false)
  isReclamation      Boolean  @default(false)
  noCommandeCheckbox Boolean? @default(false) @map("no_commande_checkbox")

  // Documents / References
  noBill        String? @db.VarChar(50)
  noBonCommande String? @db.VarChar(50)
  noReclamation String? @db.VarChar(50)

  // Workflow / People
  initiatedBy   String?
  initializedAt DateTime?
  verifiedBy    String?
  verifiedAt    DateTime?
  finalizedBy   String?
  finalizedAt   DateTime?

  // Logistics
  warehouseOrigin      String?
  warehouseDestination String?
  villeShipto          String?
  totalWeight          Decimal? @db.Decimal(10, 2)

  // Credits
  noCredit    String? @db.VarChar(50)
  noCredit2   String? @db.VarChar(50)
  noCredit3   String? @db.VarChar(50)
  creditedTo  String? @db.VarChar(50)
  creditedTo2 String? @db.VarChar(50)
  creditedTo3 String? @db.VarChar(50)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  tenant      Tenant             @relation(fields: [tenantId], references: [id])
  products    ReturnProduct[]
  attachments ReturnAttachment[]

  @@index([tenantId])
  @@index([tenantId, reportedAt])
  @@index([reportedAt])
  @@index([isDraft, isFinal, isVerified])
  @@index([expert])
  @@index([client])
  @@index([noCommande])
}

model ReturnProduct {
  id       Int @id @default(autoincrement())
  returnId Int

  codeProduit       String  @db.VarChar(50)
  quantite          Int     @default(0)
  descrProduit      String? @db.VarChar(500)
  descriptionRetour String? @db.Text

  // Processing info
  quantiteRecue Int?
  qteInventaire Int?
  qteDetruite   Int?
  tauxRestock   Decimal? @db.Decimal(5, 4)
  poids         Decimal? @db.Decimal(10, 2)
  weightProduit Decimal? @db.Decimal(10, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  return Return @relation(fields: [returnId], references: [id], onDelete: Cascade)

  @@index([returnId])
  @@index([codeProduit])
}

model ReturnAttachment {
  id       Int @id @default(autoincrement())
  returnId Int

  // ðŸ‘‡ FIXED: Added map to match the actual database column "filePath"
  fileId String @map("filePath")

  fileName String // Original file name
  mimeType String? // File MIME type (application/pdf, image/jpeg, etc.)
  fileSize Int? // File size in bytes

  // This maps the TypeScript field "createdAt" to the DB column "uploadedAt"
  createdAt DateTime @default(now()) @map("uploadedAt")

  // Relation to Return
  return Return @relation(fields: [returnId], references: [id], onDelete: Cascade)

  // Indexes for faster lookups
  @@index([returnId])
  @@index([fileId])
}

////////////////////////////////////////////////////////////////////////////////
// 4) SUPPORT TICKETS DOMAIN
////////////////////////////////////////////////////////////////////////////////

model SupportTicket {
  id   String @id @default(uuid())
  code String @unique // Format: TI-YYYYMMDD-XXXX

  // Identification (from session)
  userId    String  @map("user_id")
  userEmail String  @map("user_email")
  userName  String  @map("user_name")
  userPhone String? @map("user_phone")

  // Tenant context (auto-filled)
  tenantId             String  @map("tenant_id")
  tenantName           String  @map("tenant_name") // Denormalized for display
  entiteOperationnelle String? @map("entite_operationnelle") // Derived mapping for Monday.com

  // Location
  site        String
  departement String

  // Categorization
  categorie     String
  sousCategorie String? @map("sous_categorie")

  // Priority calculation inputs
  impact  String // Individuel, Ã‰quipe, DÃ©partement, Organisation
  portee  String // Un utilisateur, Plusieurs, DÃ©partement, Critique
  urgence String // Basse, Moyenne, Haute, Critique

  // Calculated fields
  priorite  String // P1, P2, P3, P4 (calculated)
  slaTarget DateTime? @map("sla_target")

  // Ticket content
  sujet       String
  description String @db.Text

  // Status & workflow
  statut   String  @default("nouveau") // nouveau, en_cours, en_attente, resolu, ferme
  assigneA String? @map("assigne_a")

  // Timestamps
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")
  resolvedAt DateTime? @map("resolved_at")
  closedAt   DateTime? @map("closed_at")

  // Relations
  user        User                      @relation(fields: [userId], references: [id])
  tenant      Tenant                    @relation(fields: [tenantId], references: [id])
  attachments SupportTicketAttachment[]
  comments    SupportTicketComment[]

  @@index([tenantId])
  @@index([userId])
  @@index([statut])
  @@index([priorite])
  @@map("support_tickets")
}

model SupportTicketAttachment {
  id         String   @id @default(uuid())
  ticketId   String   @map("ticket_id")
  fileName   String   @map("file_name")
  fileUrl    String   @map("file_url")
  fileSize   Int      @map("file_size")
  mimeType   String   @map("mime_type")
  uploadedAt DateTime @default(now()) @map("uploaded_at")
  commentId  String?  @map("comment_id")

  ticket  SupportTicket         @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  comment SupportTicketComment? @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@index([ticketId])
  @@index([commentId])
  @@map("support_ticket_attachments")
}

model SupportTicketComment {
  id         String   @id @default(uuid())
  ticketId   String   @map("ticket_id")
  userId     String   @map("user_id")
  userName   String   @map("user_name")
  content    String   @db.Text
  isInternal Boolean  @default(false) @map("is_internal")
  createdAt  DateTime @default(now()) @map("created_at")

  ticket      SupportTicket             @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  attachments SupportTicketAttachment[]

  @@index([ticketId])
  @@map("support_ticket_comments")
}

////////////////////////////////////////////////////////////////////////////////
// 5) NOTIFICATIONS
////////////////////////////////////////////////////////////////////////////////

model Notification {
  id       String  @id @default(uuid())
  userId   String  @map("user_id")
  tenantId String? @map("tenant_id")

  type    String // ticket_created, ticket_updated, ticket_assigned, etc.
  title   String
  message String
  link    String? // URL to navigate to

  // Reference to related entity
  entityType String? @map("entity_type") // support_ticket, etc.
  entityId   String? @map("entity_id")

  isRead    Boolean  @default(false) @map("is_read")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@index([userId, createdAt])
  @@map("notifications")
}

////////////////////////////////////////////////////////////////////////////////
// 6) CUSTOMER GEO CACHE  (schema: public â€” DMS never touches this)
////////////////////////////////////////////////////////////////////////////////

model CustomerGeoCache {
  id         Int      @id @default(autoincrement())
  tenantSlug String   @map("tenant_slug")
  custId     Int      @map("cust_id")
  lat        Float
  lng        Float
  address    String?
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  @@unique([tenantSlug, custId])
  @@index([tenantSlug])
  @@map("customer_geo_cache")
}
